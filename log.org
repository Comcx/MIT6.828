#+TITLE: MIT6.828 OS Studying log
#+AUTHOR: Comcx
#+DATE: <2019-01-19 Sat>


* [2/3] LEC 1
  SCHEDULED: <2019-01-20 Sun>
  DEADLINE:  <2019-01-27 Sun>

** DONE Xv6 resources got!
** DONE Unix Intro
** TODO [50%] LAB 1
*** DONE Got LAB resources
*** NEXT [Exercise 1] Learning Assembly languages
**** NEXT Got Assembly book -> learning Intel assembly syntax
Learning NASM syntax...
- Basic syntax already knew <2019-01-22 Tue>
- Learning more directions...
  Plan to install *NASM* tool to test Assembly codes.
***** NEXT Using /NASM/
      NASM use Intel like syntax, learning with the book...
:Operations:
-- Operations are op codes which can be directly translated to machine code.

-- MOVement
*MOV dest, source*

-- ADDition
*ADD dest source*

-- SUBtraction
*SUB dest source*

-- CoMParision
*CMP vleft, vright*

For unsigned integers, there are two flags (bits in the FLAGS register)
that are important: the zero (ZF) and carry (CF) flags. The zero flag is
set (1) if the resulting difference would be zero. The carry flag is used as a
borrow flag for subtraction. Consider a comparison like:
#+begin_src
cmp vleft, vright
#+end_src
The difference of vleft - vright is computed and the flags are set accordingly. 
If the difference of the of CMP is zero, vleft = vright, then ZF is set
(i.e. 1) and the CF is unset (i.e. 0). If vleft > vright, then ZF is unset
and CF is unset (no borrow). If vleft < vright, then ZF is unset and CF
is set (borrow)

For signed integers, there are 3 flags that are important: the ZERO flag(ZF),
OVERFLOW flag(OF), and SIGN flag(SF). The OVERFLOW flag
is set if the result of an operation overflows (or underflows). The sign flag
is set if the result of an operation is negative. If vleft = vright, the ZF
is set (just as for unsigned integers). If vleft > vright, ZF is unset and
SF = OF. If vleft < vright, ZF is unset and SF /= OF.

-- JuMPs

-- Unconsitional jump
*JMP address*

--------------------------------------
| *JZ*  | branches only if ZF is set   |
| *JNZ* | branches only if ZF is unset |
| *JO*  | branches only if OF is set   |
| *JNO* | branches only if OF is unset |
| *JS*  | branches only if SF is set   |
| *JNS* | branches only if SF is unset |
| *JC*  | branches only if CF is set   |
| *JNC* | branches only if CF is unset |
| *JP*  | branches only if PF is set   |
| *JNP* | branches only if PF is unset |
p.s. /PF/ is the parity flag which 
     indicates the _odd or evenness_ of a result.



There several variations of /JMP/ instruction:

*SHORT* 
This jump is very limited in range. It can only move up or down
_128 bytes_ in memory. The advantage of this type is that it uses less
memory than the others. It uses a single signed byte to store the
displacement of the jump. The displacement is how many bytes to
move ahead or behind. (The displacement is added to EIP). To specify
a short jump, use the SHORT keyword immediately before the label in
the JMP instruction.

*NEAR* 
This jump is the _default_ type for both unconditional and conditional branches, 
it can be used to jump to _any location in a segment_. 
Actually, the 80386 supports two types of near jumps. One
uses two bytes for the displacement. This allows one to move up or
down roughly 32,000 bytes. The other type uses four bytes for the
displacement, which of course allows one to move to any location in
the code segment. The four byte type is the default in 386 protected
mode. The two byte type can be specified by putting the WORD keyword
before the label in the JMP instruction.

*FAR* 
This jump allows control to move to _another code segment_. This is a
very rare thing to do in 386 protected mode.

-- More(advanced) jumps
| Signed     | Unsigned                                                       |
|------------+----------------------------------------------------------------|
| *JE*       | branches if vleft = vright JE branches if vleft = vright       |
| *JNE*      | branches if vleft 6= vright JNE branches if vleft 6= vright    |
| *JL, JNGE* | branches if vleft < vright JB, JNAE branches if vleft < vright |
| *JLE, JNG* | branches if vleft ≤ vright JBE, JNA branches if vleft ≤ vright |
| *JG, JNLE* | branches if vleft > vright JA, JNBE branches if vleft > vright |
| *JGE, JNL* | branches if vleft ≥ vright JAE, JNB branches if vleft ≥ vright |




-- LOOPs
*LOOP*
| *LOOP*           | Decrements ECX, if ECX 6= 0, branches to label      |
| *LOOPE, LOOPZ*   | Decrements ECX (FLAGS register is not modified), if |
|                  | ECX /= 0 and ZF = 1, branches                       |
| *LOOPNE, LOOPNZ* | Decrements ECX (FLAGS unchanged), if ECX /=         |
|                  | 0 and ZF = 0, branches                              |



-------------------------------------------

-- Bit operations

| *SHL obj bits* | Logic shift left       |
| *SHR obj bits* | Logic shift right      |
| *SAL obj bits* | Arithmetic shift left  |
| *SAR obj bits* | Arithmetic shift right |
| *ROL obj bits* | Rotate left            |
| *ROR obj bits* | Rotate right           |
| *RCL obj bits* |                        |
| *RCR obj bits* |                        |
p.s. /obj/ means object, /bits/ refers number of bits to move


-- Boolean operations

| *and* | *or* | *xor* | *not* |
*TEST* operation

The TEST instruction performs an AND operation, but does not store
the result. 
It only sets the FLAGS register based on what the result would
be (much like how the CMP instruction performs a subtraction but only sets
FLAGS).




:end:

:Directions:
-- Directions are ad-hoc codes which can be used to direct assembler to generate code.
-- Here character 'X' is special for different formats:
| Unit        | Letter |
|-------------+--------|
| Byte        | B      |
| Word        | W      |
| Double word | D      |
| Quad word   | Q      |
| Ten bytes   | T      |

*/symbol/ equ /value/*

*%define*   -- like C #define

*%include*  -- like C #include

*res/X/*    -- reserves room(unit /X/)

*d/X/*      -- reserve and initalize

*times*     -- for repeated reserve directions

:end:

*Labels* can be used conveniently: 

plain labels are their address;

squared(e.g. [label]) labels are contents inside the address of the label

:Size-Specifiers:
-- Size specifiers are used when the assembler can not infer the actual data's size of operation.

-- e.g. Suppose we have code:
#+begin_src
mov [L6], 1
#+end_src
Here, the assembler has no idea what the actual size of /[L6]/ is.
To solve this, we simply add a /size specifier/:
#+begin_src
mov dword [L6], 1
#+end_src

All size specifiers are:

*byte | word | dword | qword | tword*

:end:

*[Pitfall]* The book says file /asm_io.inc/ can be downloaded from url in book,
however, I found nothing but a plain article.
Finally, I found that the link has been updated to:

[[http://pacman128.github.io/pcasm/]]

:( cost me a lot of time.........
compiler /first.asm/ successfully!!! <2019-01-22 Tue>





**** TODO [Book] Brennan's Guide to Inline Assembly -> 
     learn AT&T syntax, which is semantically equivalent to Intel syntax.

*** DONE Build JOS environment [little difficult]
**** DONE Build *QEMU*
To build qemu for 6.828, one need to follow the instructions written
on 6.828 offical guide!
I followed everything in guide, but I still ran into /error/ while trying to
install /qemu/:
- *Situation 1: Python2.7 needed*
We have to use python under version 3 :(  

*[Solution]* Install python2.7, in my Arch, command:
#+begin_src shell
sudo pacman -S python2
#+end_src
then, in configuration phase, add option: --python=python2.7

- *Situation 2: Undefined reference to major or minor*
This cost me large amount of time to fix.
Finally, I found this /upgrade/

Android's had <sys/sysmacros.h> for a long time, we are likely to
remove the transtive include from <sys/types.h>

Therefore,
  
*[Solution]* add code:
#+begin_src c
#include <sys/sysmacros.h>
#+end_src

- *Situation 3: qemu-nox*
Since I am using pure tty in Arch, when I tried to command:

make qemu,
  
I got /error/: could not connect server.

*[Solution]* use command:  
#+begin_src shell
make qemu-nox
#+end_src

Now I've successfully built /QEMU/ environment! :)


**** DONE Debugging *QEMU*
Unfortunately, I ran into trouble again while debugging.
I followed instructions:
1) Command:
#+begin_src shell
make qemu-gdb
#+end_src
2) Open another terminal window, command in the same directory:
#+begin_src shell
make gdb
#+end_src

then, I got error message:
#+begin_src
error while loading shared libraries: libreadline.so.8
#+end_src

I tried to upgrade readline:
#+begin_src shell
sudo pacman -S readline
#+end_src

Then, cd /usr/lib, I found:

libreadline.so.8

which is already up-to-date.

However, when I ran: make qemu-gdb, error occurred again:
#+begin_src
error while loading shared libraries: libreadline.so.7
#+end_src

This time lack version 7 2333333333 :(
Finally, I cd /usr/lib, command:
#+begin_src shell
sudo ln -s libreadline.so.7 libreadline.so.8
#+end_src
to get both version 7 and 8 and everything's ok now.





*** NEXT Simiulating PC & Debug
**** DONE [Exercise 2] Follow BIOS steps by command _si_
**** DONE Understanding PC's physical address & boot
***** TODO [Book] Phil Storrs PC Hardware book

**** TODO Understanding the *Boot loader*
***** DONE The Boot sector
Most boot codes lies in the first sector of a bootable device(e.g. CD-ROM).
However, Some modern machines are now using 2 sectors to load boot codes.

See _"El Torito" Bootable CD-ROM Format Specification._

***** TODO Read the Boot Codes







